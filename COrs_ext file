from burp import IBurpExtender
from burp import IIntruderPayloadGeneratorFactory
from burp import IIntruderPayloadGenerator
import sys

# url modification module
try:
    from urllib.parse import urlparse
except ImportError:
    from urlparse import urlparse

from tld import get_tld
import tldextract

import random

PAYLOADS = [
    'test_reflect_origin',
    'test_prefix_match',
    'test_suffix_match',
    'test_trust_null',
    'test_substring_match',
    'test_https_trust_http']


class BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory):

    #
    # implement IBurpExtender
    #

    def registerExtenderCallbacks(self, callbacks):
        # obtain an extension helpers object
        self._callbacks = callbacks

        # set our extension name that we add in extender
        callbacks.setExtensionName("Payload generator extension")

        # register ourselves as an Intruder payload generator
        callbacks.registerIntruderPayloadGeneratorFactory(self)

    #
    # implement IIntruderPayloadGeneratorFactory
    #

    def getGeneratorName(self):
        return "Sample payload"

    def createNewInstance(self, attack):
        # return a new IIntruderPayloadGenerator to generate payloads for this attack
        return SampleIntruderPayloadGenerator(self, attack)

    #
    # implement IIntruderPayloadProcessor
    #


#
# class to generate payloads from a simple list
#

class SampleIntruderPayloadGenerator(IIntruderPayloadGenerator):
    def __init__(self, extender, attack):
        self._extender = extender
        self._attack = attack
        self._payloadIndex = 0

        return

    # reflecting any origin
    # www.example.com -> evil.com
    def test_reflect_origin(self, original_payload):
        test_url = original_payload
        parsed = urlparse(test_url)
        test_origin = parsed.scheme + "://" + "evil.com"

        return test_origin

    # trust prefix match
    # http://example.com -> http://example.com.evil.com
    def test_prefix_match(self, original_payload):
        test_url = original_payload
        parsed = get_tld(test_url, as_object=True)

        (url_schema, subdomain, domain, suffix) = (
        parsed.parsed_url.scheme, parsed.subdomain, parsed.domain, parsed.suffix)

        url_schema = "" if (url_schema == "") else url_schema + "://"
        subdomain = "" if (subdomain == "") else subdomain + "."
        # addition of the
        domain = "" if (domain == "") else domain + "." + suffix + ".evil."

        test_origin = url_schema + subdomain + domain + suffix

        return test_origin

    # trust suffix match
    # www.example.com -> evilexample.com
    def test_suffix_match(self, original_payload):
        test_url = original_payload
        parsed = get_tld(test_url, as_object=True)

        (url_schema, subdomain, domain, suffix) = (
            parsed.parsed_url.scheme, parsed.subdomain, parsed.domain, parsed.suffix)

        url_schema = "" if (url_schema == "") else url_schema + "://"
        subdomain = "" if (subdomain == "") else subdomain + "."
        # addition of the
        domain = "" if (domain == "") else "evil" + domain + "."

        test_origin = url_schema + subdomain + domain + suffix

        return test_origin

    # trust null
    # what ever may be the payload the origin will be null
    def test_trust_null(self, original_payload):
        test_url = original_payload
        test_origin = "null"

        return test_origin

    # trust substring
    # http://www.example.com example.co
    def test_substring_match(self, original_payload):
        test_url = original_payload
        parsed = urlparse(test_url)
        sld = tldextract.extract(test_url.strip()).registered_domain
        test_origin = parsed.scheme + "://" + sld[1:]

        return test_origin

    def test_https_trust_http(self, original_payload):
        test_url = original_payload
        parsed = urlparse(test_url)
        if parsed.scheme != "https":
            return
        test_origin = "http://" + parsed.netloc.split(':')[0]

        return test_origin

    def hasMorePayloads(self):
        return self._payloadIndex < len(PAYLOADS)

    def getNextPayload(self, current_payload):
        # convert into a string
        current_payload = "".join(chr(x) for x in current_payload)

        payload_function = PAYLOADS[self._payloadIndex]

        func = getattr(self, payload_function)
        # executing function
        payload = func(current_payload)

        # call our simple mutator to fuzz the post
        self._payloadIndex = self._payloadIndex + 1

        return payload

    def reset(self):
        self._payloadIndex = 0
        return



